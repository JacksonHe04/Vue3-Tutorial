# Vue 3 中 `ref` 与 `reactive` 的对比

## 宏观角度的对比

1. **`ref` 用来定义：**
    - **基本类型数据**（如 `number`、`string` 等）。
    - **对象类型数据**（虽然 `reactive` 更适合处理对象类型数据，但 `ref` 同样能处理对象）。

2. **`reactive` 用来定义：**
    - **对象类型数据**，特别是当你需要一个**深层次**响应式对象时。

## 主要区别

1. **`ref` 需要使用 `.value`：**
    - `ref` 创建的响应式数据，必须通过 `.value` 来访问和修改它的值。即使是对象类型的数据也如此。
    - 在模板中，Vue 会自动解包 `.value`，但在 JavaScript 代码中访问时，你必须手动添加 `.value`。
    - 为了方便开发，可以使用 `Volar` 插件来自动补充 `.value`，避免手动写入。

2. **`reactive` 对象的重新分配问题：**
    - 使用 `reactive` 创建的响应式对象，是通过 `Proxy` 代理的。如果直接用 `Object.assign()` 或其他方法重新分配对象的内容，这会**失去响应式**，因为它会创建一个新的对象。
    - 如果需要替换 `reactive` 对象的内容，可以使用 `Object.assign` 或其他方法，但要注意这会影响响应式的行为。
    - 例如：
      ```js
      let obj = reactive({ a: 1 });
      Object.assign(obj, { b: 2 }); // 这会失去响应式，obj变成了一个普通对象
      ```

## 使用原则

### 1. **基本类型的响应式数据，必须使用 `ref`：**
- 对于单纯的基本数据类型（如数字、字符串、布尔值等），应使用 `ref`。Vue 会自动处理其响应式。

### 2. **对于简单的对象，`ref` 和 `reactive` 都可以：**
- 当你只需要一个平坦的（即层级不深的）对象，并且不需要深度响应式时，`ref` 和 `reactive` 都能胜任。
- 在这种情况下，选择 `ref` 还是 `reactive` 取决于你的个人习惯或者代码风格。`ref` 可能会让你觉得稍微简洁，但 `reactive` 可以让你更自然地处理对象的深层次更新。

### 3. **对于深层次对象，推荐使用 `reactive`：**
- 如果对象的嵌套层次较深，且你希望能够自动追踪每一层的变化，`reactive` 是更合适的选择。它会自动处理对象中每一层的属性响应式，而 `ref` 只能对引用本身进行响应式处理。
- 例如，嵌套对象的属性更新：
  ```js
  let obj = reactive({
    a: {
      b: {
        c: 1
      }
    }
  });

  obj.a.b.c = 2; // 这个修改会自动更新视图
  ```

## 总结

- **`ref`** 适用于基本类型和对象类型数据，尤其是当你需要响应式的基本数据类型时（如数字、字符串等）。对于对象，`ref` 需要通过 `.value` 来访问。
- **`reactive`** 更适用于深层次嵌套的对象数据，它自动处理每个层级的属性响应式。但如果你需要重新分配对象或替换对象，必须小心，因为它可能会丧失响应式。
- **使用原则：**
    - 基本类型数据：`ref`。
    - 简单对象：`ref` 或 `reactive`。
    - 深层嵌套对象：`reactive`。

在实际开发中，虽然 `ref` 更加通用，但 `reactive` 在处理复杂数据结构时更具优势，尤其是在需要深层次响应式时。